import React, { useState, useMemo, useEffect } from 'react';
import ReactDOMServer from 'react-dom/server';
import { useAppState } from '../state/AppStateContext';
import { JobDescription, Resume, CoverLetter, AppState } from '../types';
import { parseJobDescription, isAIConfigured, fetchJobDescriptionFromURL } from '../utils/aiService';
import { saveJobDescription, deleteJobDescription, exportAllDataAsJSON } from '../storage';



import { logStatusChange, logActivity } from '../utils/activityLogger';
import { extensionService, ExtensionJobData, ExtensionService } from '../utils/extensionService';

import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import remarkBreaks from 'remark-breaks';
import GeneratedContentModal from '../components/GeneratedContentModal';
import ValidationMessage from '../components/ValidationMessage';
import CSVImportModal from '../components/CSVImportModal';
import StorageMonitor from '../components/StorageMonitor';
import JobManagementTable from '../components/JobManagementTable';
import StatusDropdown from '../components/StatusDropdown';
import AnalyticsDashboard from '../components/AnalyticsDashboard';
import ActionReminderPanel from '../components/ActionReminderPanel';
import MainTabContent from '../components/MainTabContent';
import AddJobForm from '../components/AddJobForm';
import JobStatsSection from '../components/JobStatsSection';
import JobDescriptionsContent from '../components/JobDescriptionsContent';
import ToastNotification, { Toast } from '../components/ToastNotification';
import DuplicateJobModal from '../components/DuplicateJobModal';
import ReminderSettingsModal from '../components/ReminderSettingsModal';
import TabNavigation from '../components/TabNavigation';
import ModalManager from '../components/ModalManager';
import JobFilters from '../components/JobFilters';
import JobListDisplay from '../components/JobListDisplay';
import { JobScraperModal } from '../components/JobScraperModal';
import { JobDetailsPanel } from '../components/JobDetailsPanel';
import { JobEditModal } from '../components/JobEditModal';
import { useJobFormData, JobDescriptionFormData } from '../hooks/useJobFormData';
import { useToastManager } from '../hooks/useToastManager';
import { useModalManager } from '../hooks/useModalManager';
import { useUIState } from '../hooks/useUIState';
import { useJobActions } from '../hooks/useJobActions';
import { useJobAnalytics } from '../hooks/useJobAnalytics';
import { useJobFormHandlers } from '../hooks/useJobFormHandlers';
import { useJobManagementHandlers } from '../hooks/useJobManagementHandlers';
import { useGenerationHandlers } from '../hooks/useGenerationHandlers';
import { useJobPageState } from '../hooks/useJobPageState';
import {
  extractSalaryMin,
  extractSalaryMax,
  formatCurrency,
  getImpactIcon,
  getImpactColor,
  createTextHash,
  needsAIParsing,
  calculateAICost,
  estimateCost
} from '../utils/jobDescriptionHelpers';
import { smartParseJobDescription } from '../utils/aiParsingService';
import { cleanLinkedInUrl, isJobUnparsed, convertJobDescriptionToFormData } from '../utils/jobFormUtils';

import './JobDescriptionsPage.css';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faThumbsUp, faMinus, faFire, faTimes, faEdit, faCopy, faTable, faFileAlt, faFileImport, faChartBar, faDollarSign, faSync, faArrowUp, faArrowDown, faCheck, faExclamationTriangle, faPaperclip, faPlus, faSearch, faEye, faDownload, faUpload, faCog } from '@fortawesome/free-solid-svg-icons';

const JobDescriptionsPage: React.FC = () => {
  const { state, setState } = useAppState();
  const pageState = useJobPageState();
  const {
    activeTab, setActiveTab,
    showReminderSettings, setShowReminderSettings,
    selectedJobId, setSelectedJobId,
    editingJobId, setEditingJobId,
    editingNotesId, setEditingNotesId,
    tempNotes, setTempNotes,
    showArchivedJobs, setShowArchivedJobs,
    hideRejectedJobs, setHideRejectedJobs,
    showOnlyWaitingJobs, setShowOnlyWaitingJobs,
    showUnparsedFirst, setShowUnparsedFirst,
    searchQuery, setSearchQuery,
    duplicateSearchQuery, setDuplicateSearchQuery,
    statusFilter, setStatusFilter,
    showExpandedStats, setShowExpandedStats,
    chartType, setChartType,
    aiParseCache, setAiParseCache,
    linkedDocumentsSearch, setLinkedDocumentsSearch
  } = pageState;


  const { toasts, showToast, removeToast } = useToastManager();
  const modalManager = useModalManager();
  const uiState = useUIState();
  const jobActions = useJobActions(setState, showToast, modalManager.setScraperModalOpen);
  const statsData = useJobAnalytics(state.jobDescriptions);
  const {
    formData,
    setFormData,
    createEmptyFormData,
    updateFormData,
    resetFormData,
    convertToJobDescription
  } = useJobFormData();
  const formHandlers = useJobFormHandlers();
  const managementHandlers = useJobManagementHandlers();
  const generationHandlers = useGenerationHandlers();













  useEffect(() => {
    const handleExtensionJobData = (extensionData: ExtensionJobData) => {
      try {

        const jobDescription = ExtensionService.convertToJobDescription(extensionData);


        setState(prevState => ({
          ...prevState,
          jobDescriptions: [...prevState.jobDescriptions, jobDescription]
        }));


        const jobWithActivity = logActivity(jobDescription, 'field_updated', {
          field: 'imported',
          toValue: true,
          details: `Imported from ${extensionData.source} via browser extension`
        });


        saveJobDescription(jobWithActivity);


        showToast(
          `Job "${jobDescription.title}" imported from browser extension!`,
          'success',
          5000
        );

        console.log('Successfully imported job from extension:', jobDescription);
      } catch (error) {
        console.error('Error importing job from extension:', error);
        showToast('Failed to import job from browser extension', 'error');
      }
    };


    extensionService.addJobDataListener(handleExtensionJobData);


    return () => {
      extensionService.removeJobDataListener(handleExtensionJobData);
    };
  }, [setState]);



  // Job creation handler now provided by useJobActions hook
  const handleScrapedJobCreated = handleScrapedJob;

  // Event handlers now provided by useJobActions hook
  const {
    handleExportData,
    handleImportData,
    handleScrapedJob,
    handleDeleteJob,
    handleToggleArchive,
    handleDuplicateJob,
    handleUpdateJob,
    handleParseAllUnparsed,
    isExporting,
    isImporting
  } = jobActions;

  // Analytics and cache state now managed by useJobPageState hook

  // Analytics data now provided by useJobAnalytics hook

  // Generation and modal states now managed by extracted hooks

  // Get next sequential job ID
  const getNextSequentialId = (): number => {
    if (state.jobDescriptions.length === 0) return 1;
    const maxId = Math.max(...state.jobDescriptions.map(jd => jd.sequentialId || 0));
    return maxId + 1;
  };

  // Form handlers now provided by useJobFormHandlers hook
  const handleFetchURL = () => formHandlers.handleFetchURL(formData.url || '', formData, setFormData);

  // Auto-parse job description text to extract title, company, etc.

  // Reparse handler now provided by useJobFormHandlers hook
  const handleReparse = () => {
    const existingJob = editingJobId ? state.jobDescriptions.find(job => job.id === editingJobId) || null : null;
    return formHandlers.handleReparse(
      formData.rawText, formData, setFormData, aiParseCache, setAiParseCache,
      editingJobId, existingJob, setState, showToast, getNextSequentialId
    );
  };

  // Process job handler now provided by useJobManagementHandlers hook  
  const handleProcessJob = (jobId: string) => {
    return managementHandlers.handleProcessJob(
      jobId, state, setState, showToast, getNextSequentialId,
      aiParseCache, setAiParseCache, (processing: boolean) => { } // setIsProcessing stub
    );
  };

  const handleEditJobDescription = (jobId: string) => {
    const job = state.jobDescriptions.find(jd => jd.id === jobId);
    if (job) {
      setJobBeingEdited(job);
      setEditModalOpen(true);
    }
  };

  const handleSaveEditedJob = async (updatedJob: JobDescription) => {
    try {
      setState(prev => ({ ...prev, jobDescriptions: prev.jobDescriptions.map(jd => jd.id === updatedJob.id ? updatedJob : jd) }));
      await saveJobDescription(updatedJob);
      showToast('Job updated successfully!', 'success');
      setEditModalOpen(false);
      setJobBeingEdited(null);
    } catch (error) {
      console.error('Error saving edited job:', error);
      showToast('Failed to save changes. Please try again.', 'error');
      throw error;
    }
  };

  const handleCancelEdit = () => {
    setEditingJobId(null);
    setFormData({
      rawText: '',
      title: '',
      company: '',
      role: '',
      location: '',
      workArrangement: '',
      impact: 'low',
      priority: '',
      salaryMin: '',
      salaryMax: '',
      salaryRange: '',
      sequentialId: '',
      url: '',
      source1Type: 'text',
      source1Content: '',
      source2Type: 'text',
      source2Content: '',
      contactName: '',
      contactEmail: '',
      contactPhone: '',
      applicationDate: '',
      applicationStatus: '',
      interviewStage: '',
      offerStage: '',
      additionalContext: '',
      notes: '',
      isArchived: false,
      duplicateOfId: '',
      linkedDuplicateIds: [],
      submissionDate: '',
      lastActivityDate: '',
      source: '',
      contactPerson: '',
      secondaryContact: '',
      waitingForResponse: false,
      followUpDate: '',
      interviewDates: [],
      salaryDiscussed: '',
      statusHistory: [],
      activityLog: [],
      daysSinceApplication: 0,
      daysInCurrentStatus: 0,
      completedActions: {},
      snoozedUntil: {}
    });
    setFetchError(null);
    setIsFetchingURL(false);
    setLastParseUsage(null); // Clear usage when canceling
    // Save job handler provided by useJobFormHandlers hook  
    const handleSaveJobDescription = () => {
      return formHandlers.handleSaveJobDescription(
        formData, editingJobId, state, setState, showToast, getNextSequentialId,
        aiParseCache, setAiParseCache, resetFormData
      );
    };
    setAiParseCache,
    {
      applicationDate: new Date().toISOString().split('T')[0],
      applicationId: sequentialId,
      impactFocus: 'New Job Description',
      impactLevel: 'Standard'
    }
            );

if (parseResult.success && parseResult.extractedInfo) {
  // Update extracted info
  newJobDescription.extractedInfo = parseResult.extractedInfo;
  newJobDescription.keywords = parseResult.keywords || [];

  // Track AI usage (only if not from cache)
  if (parseResult.usage && !parseResult.fromCache) {
    const textHash = createTextHash(formData.rawText.trim());
    const estimatedCost = calculateAICost(parseResult.usage);
    newJobDescription.aiUsage = {
      totalTokens: parseResult.usage.totalTokens,
      promptTokens: parseResult.usage.promptTokens,
      completionTokens: parseResult.usage.completionTokens,
      estimatedCost: estimatedCost,
      parseCount: 1,
      lastParseDate: new Date().toISOString(),
      rawTextHash: textHash
    };
  } else if (parseResult.fromCache) {
    // If from cache, set a minimal usage record to track that it was processed
    const textHash = createTextHash(formData.rawText.trim());
    newJobDescription.aiUsage = {
      totalTokens: 0,
      promptTokens: 0,
      completionTokens: 0,
      estimatedCost: 0,
      parseCount: 0,
      lastParseDate: new Date().toISOString(),
      rawTextHash: textHash
    };
  }
}
          } catch (parseError) {
  console.warn('Failed to parse job description with AI:', parseError);
  // Continue with saving even if AI parsing fails
}
        }

await saveJobDescription(newJobDescription);

setState(prev => ({
  ...prev,
  jobDescriptions: [...prev.jobDescriptions, newJobDescription]
}));
      }

// Reset form
setFormData({
  rawText: '',
  title: '',
  company: '',
  role: '',
  location: '',
  workArrangement: '',
  impact: 'low',
  priority: '',
  salaryMin: '',
  salaryMax: '',
  salaryRange: '',
  sequentialId: '',
  url: '',
  source1Type: 'text',
  source1Content: '',
  source2Type: 'text',
  source2Content: '',
  contactName: '',
  contactEmail: '',
  contactPhone: '',
  applicationDate: '',
  applicationStatus: '',
  interviewStage: '',
  offerStage: '',
  additionalContext: '',
  notes: '',
  isArchived: false,
  duplicateOfId: '',
  linkedDuplicateIds: [],
  submissionDate: '',
  lastActivityDate: '',
  source: '',
  contactPerson: '',
  secondaryContact: '',
  waitingForResponse: false,
  followUpDate: '',
  interviewDates: [],
  salaryDiscussed: '',
  statusHistory: [],
  activityLog: [],
  daysSinceApplication: 0,
  daysInCurrentStatus: 0,
  completedActions: {},
  snoozedUntil: {}
});

showToast('Job description saved successfully!', 'success');

    } catch (error) {
  console.error('Error saving job description:', error);
  showToast('Failed to save job description. Please try again.', 'error');
} finally {
  setIsProcessing(false);
}
  };

const handleDeleteJobDescription = (id: string) => managementHandlers.handleDeleteJobDescription(id, setState, showToast);

const handleArchiveJob = (id: string) => managementHandlers.handleArchiveJob(id, setState, showToast);

const handleUnarchiveJob = (id: string) => managementHandlers.handleUnarchiveJob(id, setState, showToast);

const handleToggleWaitingForResponse = (id: string) => managementHandlers.handleToggleWaitingForResponse(id, state, setState, showToast);
  };

const handleMarkDuplicate = async (jobId: string) => {
  setDuplicateJobId(jobId);
  setDuplicateSearchQuery('');
  setShowDuplicateModal(true);
};

const handleConfirmDuplicate = async (originalJobId: string) => {
  if (!duplicateJobId) return;

  try {
    setState(prev => ({
      ...prev,
      jobDescriptions: prev.jobDescriptions.map(job => {
        if (job.id === duplicateJobId) {
          // Mark as duplicate and archive
          return {
            ...logActivity(job, 'status_change', {
              fromValue: job.applicationStatus || 'not_applied',
              toValue: 'duplicate',
              field: 'applicationStatus',
              details: `Marked as duplicate of job ${originalJobId}`
            }),
            applicationStatus: 'duplicate' as JobDescription['applicationStatus'],
            duplicateOfId: originalJobId,
            isArchived: true
          };
        } else if (job.id === originalJobId) {
          // Add to linked duplicates
          return {
            ...job,
            linkedDuplicateIds: [...(job.linkedDuplicateIds || []), duplicateJobId]
          };
        }
        return job;
      })
    }));

    setShowDuplicateModal(false);
    setDuplicateJobId(null);
    showToast('Job marked as duplicate and archived', 'success');
  } catch (error) {
    console.error('Error marking job as duplicate:', error);
    showToast('Failed to mark job as duplicate. Please try again.', 'error');
  }
};

const handleLinkResume = async (jobId: string, resumeId: string) => {
  const jobDescription = state.jobDescriptions.find(jd => jd.id === jobId);
  if (!jobDescription) return;

  const updatedJobDescription: JobDescription = {
    ...jobDescription,
    // Document linking feature removed
  };

  try {
    await saveJobDescription(updatedJobDescription);
    setState(prev => ({
      ...prev,
      jobDescriptions: prev.jobDescriptions.map(jd =>
        jd.id === jobId ? updatedJobDescription : jd
      )
    }));
  } catch (error) {
    console.error('Error linking resume:', error);
    showToast('Failed to link resume. Please try again.', 'error');
  }
};

const handleLinkCoverLetter = async (jobId: string, coverLetterId: string) => {
  const jobDescription = state.jobDescriptions.find(jd => jd.id === jobId);
  if (!jobDescription) return;

  const updatedJobDescription: JobDescription = {
    ...jobDescription,
    // Document linking feature removed
  };

  try {
    await saveJobDescription(updatedJobDescription);
    setState(prev => ({
      ...prev,
      jobDescriptions: prev.jobDescriptions.map(jd =>
        jd.id === jobId ? updatedJobDescription : jd
      )
    }));
  } catch (error) {
    console.error('Error linking cover letter:', error);
    showToast('Failed to link cover letter. Please try again.', 'error');
  }
};

const handleStatusChange = (jobId: string, status: JobDescription['applicationStatus'], interviewStage?: JobDescription['interviewStage'], offerStage?: JobDescription['offerStage']) => managementHandlers.handleStatusChange(jobId, status, interviewStage, offerStage, state, setState, showToast);

const handleQuickNote = (jobId: string, noteText: string) => managementHandlers.handleQuickNote(jobId, noteText, state, setState);

const handleEditNotes = (jobId: string) => managementHandlers.handleEditNotes(jobId, setEditingNotesId, setTempNotes, state);

const handleSaveNotes = (jobId: string) => managementHandlers.handleSaveNotes(jobId, tempNotes, state, setState, setEditingNotesId, setTempNotes);
    } catch (error) {
  console.error('Error saving notes:', error);
  alert('Failed to save notes. Please try again.');
}
  };

const handleCancelNotesEdit = () => managementHandlers.handleCancelNotesEdit(setEditingNotesId, setTempNotes);



// Generation handlers now provided by useGenerationHandlers hook
const handleGenerateResume = (jobDescription: JobDescription) => generationHandlers.handleGenerateResume(jobDescription, showToast);
setIsGenerating(false);
setIsGeneratingResume(false);
    }
  };

// Generate tailored cover letter
const handleGenerateCoverLetter = (jobDescription: JobDescription) => generationHandlers.handleGenerateCoverLetter(jobDescription, showToast);

const handleSaveGenerated = (name: string, content: string) => generationHandlers.handleSaveGenerated(name, content, selectedJob, showToast, setState);

const handleCSVImport = (jobDescriptions: JobDescription[]) => generationHandlers.handleCSVImport(jobDescriptions, setState, showToast);
console.error('Error importing CSV:', error);
showToast(`Failed to import job descriptions: ${error instanceof Error ? error.message : 'Unknown error'}`, 'error');
    }
  };

// Simple preview function that opens content in new tab
const handlePreviewDocument = (document: Resume | CoverLetter) => {
  const content = document.textContent || 'No content available';
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  window.open(url, '_blank');
  // Clean up the URL object after a short delay
  setTimeout(() => URL.revokeObjectURL(url), 100);
};





const selectedJob = selectedJobId ? state.jobDescriptions.find(jd => jd.id === selectedJobId) : null;

// Calculate statistics for components
const totalJobs = state.jobDescriptions.length;
const activeJobs = state.jobDescriptions.filter(jd => !jd.isArchived && jd.applicationStatus !== 'rejected').length;
const waitingJobs = state.jobDescriptions.filter(jd => jd.waitingForResponse).length;
const unparsedJobsCount = state.jobDescriptions.filter(jd => !jd.extractedInfo || (!jd.extractedInfo.requiredSkills?.length && !jd.extractedInfo.preferredSkills?.length)).length;

return (
  <div className="job-descriptions-page">
    <TabNavigation
      activeTab={activeTab}
      onTabChange={setActiveTab}
      onAddJob={() => setScraperModalOpen(true)}
      onImportCSV={() => setShowCSVImportModal(true)}
      onExport={handleExportData}
      onImport={() => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = handleImportData;
        input.click();
      }}
      onReminderSettings={() => setShowReminderSettings(true)}
      isExporting={isExporting}
      isImporting={isImporting}
    />

    <MainTabContent
      activeTab={activeTab}
      state={state}
      showArchivedJobs={showArchivedJobs}
      setShowArchivedJobs={setShowArchivedJobs}
      hideRejectedJobs={hideRejectedJobs}
      setHideRejectedJobs={setHideRejectedJobs}
      showOnlyWaitingJobs={showOnlyWaitingJobs}
      setShowOnlyWaitingJobs={setShowOnlyWaitingJobs}
      showUnparsedFirst={showUnparsedFirst}
      setShowUnparsedFirst={setShowUnparsedFirst}
      searchQuery={searchQuery}
      setSearchQuery={setSearchQuery}
      statusFilter={statusFilter}
      setStatusFilter={setStatusFilter}
      editingNotesId={editingNotesId}
      tempNotes={tempNotes}
      setTempNotes={setTempNotes}
      selectedJob={selectedJob}
      onJobSelect={setSelectedJobId}
      onDeleteJob={handleDeleteJobDescription}
      onArchiveJob={handleArchiveJob}
      onUnarchiveJob={handleUnarchiveJob}
      onToggleWaiting={handleToggleWaitingForResponse}
      onStatusChange={handleStatusChange}
      onQuickNote={handleQuickNote}
      onEditNotes={handleEditNotes}
      onSaveNotes={handleSaveNotes}
      onCancelNotes={handleCancelNotesEdit}
      onGenerateResume={handleGenerateResume}
      onGenerateCoverLetter={handleGenerateCoverLetter}
      onEditJob={handleEditJobDescription}
      onPreviewJob={setJobBeingPreviewed}
      onProcessJob={handleProcessJob}
      totalJobs={totalJobs}
      activeJobs={activeJobs}
      waitingJobs={waitingJobs}
      unparsedJobsCount={unparsedJobsCount}
      statsData={statsData}
      chartType={chartType}
      setChartType={setChartType}
      showExpandedStats={showExpandedStats}
      setShowExpandedStats={setShowExpandedStats}
    />

    {/* Disabled legacy form and content */}
    {false && (
      <AddJobForm
        editingJobId={editingJobId}
        formData={formData}
        setFormData={setFormData}
        isProcessing={formHandlers.isProcessing}
        onSave={handleSaveJobDescription}
        onCancel={handleCancelEdit}
        getNextSequentialId={getNextSequentialId}
        onFetchURL={handleFetchURL}
        isFetchingURL={formHandlers.isFetchingURL}
        fetchError={formHandlers.fetchError}
        onReparse={handleReparse}
        isReparsing={formHandlers.isReparsing}
        lastParseUsage={formHandlers.lastParseUsage}
      />
    )}

    {
      activeTab === 'job-descriptions' && state.jobDescriptions.length > 0 && (
        <JobStatsSection
          statsData={statsData}
          statusFilter={statusFilter}
          setStatusFilter={setStatusFilter}
          showExpandedStats={showExpandedStats}
          setShowExpandedStats={setShowExpandedStats}
          chartType={chartType}
          setChartType={setChartType}
        />
      )}


    {
      activeTab === 'job-descriptions' && (
        <JobDescriptionsContent
          state={state}
          searchQuery={searchQuery}
          setSearchQuery={setSearchQuery}
          showArchivedJobs={showArchivedJobs}
          setShowArchivedJobs={setShowArchivedJobs}
          hideRejectedJobs={hideRejectedJobs}
          setHideRejectedJobs={setHideRejectedJobs}
          showOnlyWaitingJobs={showOnlyWaitingJobs}
          setShowOnlyWaitingJobs={setShowOnlyWaitingJobs}
          showUnparsedFirst={showUnparsedFirst}
          setShowUnparsedFirst={setShowUnparsedFirst}
          statusFilter={statusFilter}
          selectedJobId={selectedJobId}
          setSelectedJobId={setSelectedJobId}
          onEditJob={handleEditJobDescription}
          onDeleteJob={handleDeleteJobDescription}
          onArchiveJob={handleArchiveJob}
          onUnarchiveJob={handleUnarchiveJob}
          onMarkDuplicate={handleMarkDuplicate}
          onStatusChange={handleStatusChange}
          onToggleWaitingForResponse={handleToggleWaitingForResponse}
          onProcessJob={handleProcessJob}
          onQuickNote={handleQuickNote}
        />
            {
      state.jobDescriptions.length === 0 ? (
        <div className="empty-state">
          <p>No job descriptions yet. Add one to get started!</p>
        </div>
      ) : (
        <>
          <div className="job-filters">
            <div className="search-container">
              <input
                type="text"
                placeholder="Search jobs (company, title, role...)"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="search-input"
              />
            </div>
            <label className="filter-checkbox">
              <input
                type="checkbox"
                checked={showArchivedJobs}
                onChange={(e) => setShowArchivedJobs(e.target.checked)}
              />
              Show archived jobs
            </label>
            <label className="filter-checkbox">
              <input
                type="checkbox"
                checked={hideRejectedJobs}
                onChange={(e) => setHideRejectedJobs(e.target.checked)}
              />
              Hide rejected applications
            </label>
            <label className="filter-checkbox">
              <input
                type="checkbox"
                checked={showOnlyWaitingJobs}
                onChange={(e) => setShowOnlyWaitingJobs(e.target.checked)}
              />
              Show only waiting for response
            </label>
            <label className="filter-checkbox">
              <input
                type="checkbox"
                checked={showUnparsedFirst}
                onChange={(e) => setShowUnparsedFirst(e.target.checked)}
              />
              Show unparsed jobs first
            </label>
          </div>



          <div className={`jobs-layout ${selectedJob ? 'split-view' : 'full-width'}`}>
            <JobManagementTable
              jobs={(() => {
                let filteredJobs = state.jobDescriptions;

                // Filter out archived/duplicates if not showing archived
                if (!showArchivedJobs) {
                  filteredJobs = filteredJobs.filter(job =>
                    !job.isArchived &&
                    job.applicationStatus !== 'archived' &&
                    job.applicationStatus !== 'duplicate'
                  );
                }

                // Filter out rejected if hiding rejected
                if (hideRejectedJobs) {
                  filteredJobs = filteredJobs.filter(job =>
                    job.applicationStatus !== 'rejected'
                  );
                }

                // Show only waiting jobs if filter is enabled
                if (showOnlyWaitingJobs) {
                  filteredJobs = filteredJobs.filter(job =>
                    job.waitingForResponse === true
                  );
                }

                // Apply status filter
                if (statusFilter) {
                  filteredJobs = filteredJobs.filter(job => {
                    const jobStatus = job.applicationStatus || 'not_applied';
                    return jobStatus === statusFilter;
                  });
                }

                // Apply search filter
                if (searchQuery.trim()) {
                  const query = searchQuery.toLowerCase().trim();
                  filteredJobs = filteredJobs.filter(job =>
                    job.company.toLowerCase().includes(query) ||
                    job.title.toLowerCase().includes(query) ||
                    (job.role && job.role.toLowerCase().includes(query)) ||
                    (job.extractedInfo.role && job.extractedInfo.role.toLowerCase().includes(query)) ||
                    (job.location && job.location.toLowerCase().includes(query)) ||
                    (job.extractedInfo.location && job.extractedInfo.location.toLowerCase().includes(query)) ||
                    (job.source && job.source.toLowerCase().includes(query))
                  );
                }

                // Sort to prioritize unparsed jobs if enabled
                if (showUnparsedFirst) {
                  filteredJobs = filteredJobs.sort((a, b) => {
                    const aUnparsed = isJobUnparsed(a);
                    const bUnparsed = isJobUnparsed(b);

                    // Unparsed jobs first
                    if (aUnparsed && !bUnparsed) return -1;
                    if (!aUnparsed && bUnparsed) return 1;

                    // Within same category (both parsed or both unparsed), sort by upload date (newest first)
                    const aDate = new Date(a.uploadDate).getTime();
                    const bDate = new Date(b.uploadDate).getTime();
                    return bDate - aDate;
                  });
                }

                return filteredJobs;
              })()}
              onEdit={handleEditJobDescription}
              onDelete={handleDeleteJobDescription}
              onArchive={handleArchiveJob}
              onUnarchive={handleUnarchiveJob}
              onMarkDuplicate={handleMarkDuplicate}
              onStatusChange={handleStatusChange}
              onToggleWaitingForResponse={handleToggleWaitingForResponse}
              onProcessJob={handleProcessJob}
              onSelect={setSelectedJobId}
              selectedJobId={selectedJobId}
              preserveOrder={showUnparsedFirst}
            />

            {selectedJob && (
              <JobDetailsPanel
                selectedJob={selectedJob}
                onClose={() => setSelectedJobId(null)}
                onEdit={handleEditJobDescription}
                onDelete={handleDeleteJobDescription}
                onQuickNote={handleQuickNote}
              />
            )}
          </div>
        </>
      )
    }
  </div >
)
}
      </div >

      <GeneratedContentModal
        isOpen={showGeneratedModal}
        onClose={() => setShowGeneratedModal(false)}
        onSave={handleSaveGenerated}
        title={generatedTitle}
        content={generatedContent}
        isLoading={isGenerating}
        error={generationError || undefined}
        defaultName={generatedDefaultName}
      />



      <ModalManager
        showGeneratedModal={showGeneratedModal}
        generatedTitle={generatedTitle}
        generatedContent={generatedContent}
        isGenerating={isGenerating}
        generationError={generationError}
        generatedDefaultName={generatedDefaultName}
        onCloseGeneratedModal={() => setShowGeneratedModal(false)}
        onSaveGenerated={handleSaveGenerated}
        
        showCSVImportModal={showCSVImportModal}
        onCloseCSVImportModal={() => setShowCSVImportModal(false)}
        onCSVImport={handleCSVImport}
        existingJobs={state.jobDescriptions}
        
        scraperModalOpen={scraperModalOpen}
        onCloseScraperModal={() => setScraperModalOpen(false)}
        onJobCreated={handleScrapedJobCreated}
        
        jobBeingEdited={jobBeingEdited}
        editModalOpen={editModalOpen}
        onCloseEditModal={() => {
          setEditModalOpen(false);
          setJobBeingEdited(null);
        }}
        onSaveEditedJob={handleSaveEditedJob}
        
        showDuplicateModal={showDuplicateModal}
        duplicateJobId={duplicateJobId}
        duplicateSearchQuery={duplicateSearchQuery}
        onCloseDuplicateModal={() => setShowDuplicateModal(false)}
        onDuplicateSearchChange={setDuplicateSearchQuery}
        onConfirmDuplicate={handleConfirmDuplicate}
        
        showReminderSettings={showReminderSettings}
        onCloseReminderSettings={() => setShowReminderSettings(false)}
        onJobUpdate={(updatedJob: JobDescription) => {
          setState(prev => ({
            ...prev,
            jobDescriptions: prev.jobDescriptions.map(jd =>
              jd.id === updatedJob.id ? updatedJob : jd
            )
          }));
          saveJobDescription(updatedJob).catch(error => {
            console.error('Error saving job description:', error);
            showToast('Failed to save job description. Please try again.', 'error');
          });
        }}
        jobs={state.jobDescriptions.filter(job =>
          !job.isArchived &&
          job.applicationStatus !== 'archived' &&
          job.applicationStatus !== 'duplicate'
        )}
      />

      <ToastNotification toasts={toasts} onRemoveToast={removeToast} />

{/* Floating Action Reminder Panel */ }
<ActionReminderPanel
  floating={true}
  jobs={(() => {
    let filteredJobs = state.jobDescriptions;

    // Filter out archived/duplicates for reminders
    filteredJobs = filteredJobs.filter(job =>
      !job.isArchived &&
      job.applicationStatus !== 'archived' &&
      job.applicationStatus !== 'duplicate'
    );

    return filteredJobs;
  })()}
  onJobUpdate={(updatedJob: JobDescription) => {
    setState(prev => ({
      ...prev,
      jobDescriptions: prev.jobDescriptions.map(jd =>
        jd.id === updatedJob.id ? updatedJob : jd
      )
    }));

    // Save to storage
    saveJobDescription(updatedJob).catch(error => {
      console.error('Error saving job description:', error);
      showToast('Failed to save job description. Please try again.', 'error');
    });
  }}
/>
    </div >
  );
};

export default JobDescriptionsPage;